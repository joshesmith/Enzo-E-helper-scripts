# Joshua Smith
# 18/02/2020
# Compares the values of a single field in two HDF5 files generated by Enzo-E. Calculates and prints the L2 error norm,
# Pipe the printed outputs to text file as needed.
# takes two file names (paths) and a field name as input.

import h5py
import sys
import math


def get_sum_squared_error(actual, approx) -> tuple:
    """
    :param actual: 2D or 3D HDF5 dataset of scalars - true value
    :param approx: 2D or 3D HDF5 dataset of scalars - with errors
    :return: tuple containing (error^2,actual^2)
    """
    numerator = 0
    denominator = 0
    size = actual.shape
    # 2D case
    if len(size) == 2:
        for i in range(size[0]):
            for j in range(size[1]):
                numerator += ((actual[i][j] - approx[i][j]) ** 2)
                denominator += (actual[i][j] ** 2)
        return (numerator,denominator)
    # 3D case
    elif len(size) == 3:
        for i in range(size[0]):
            for j in range(size[1]):
                for k in range(size[2]):
                    numerator += ((actual[i][j][k] - approx[i][j][k]) ** 2)
                    denominator += (actual[i][j][k] ** 2)
        return (numerator,denominator)
    else:
        assert "size of block not 2D or 3D"

def is_empty_block(block):
    """
    takes a HDF5 dataset and returns true if it contains any non-zero elements
    (important as non-leaf blocks in Enzo-E are generally all zero)
    """
    size = block.shape
    # 2D case
    if len(size) == 2:
        for i in range(size[0]):
            for j in range(size[1]):
                if block[i][j] != 0:
                    return False
    # 3D case
    elif len(size) == 3:
        for i in range(size[0]):
            for j in range(size[1]):
                for k in range(size[2]):
                    if block[i][j][k] != 0:
                        return False
    else:
        assert "size of block not 2D or 3D"
    return True

def compare_data_files(file_name_true: str,file_name_approx: str, field_name: str, max_blocks = None):
    """
    :param max_blocks: optional maximum number of blocks to check. (useful given time constraints if multiple files)
    :return:
    """
    with h5py.File(file_name_true, 'r') as bcg:
        with h5py.File(file_name_approx, 'r') as dd:
            block_errors = [] # will store the errors for each block as (numer/denom)

            for block_name in list(bcg.keys()):
                if (max_blocks is not None) and (len(block_errors) >= max_blocks):
                    break

                potential_bcg = bcg[block_name][field_name]
                potential_dd = dd[block_name][field_name]
                # check whether this is a completely empty (non-root) block
                if is_empty_block(potential_bcg):
                    pass
                else:
                    sum_squared_error = get_sum_squared_error(potential_bcg, potential_dd)
                    block_errors.append(sum_squared_error)
                    if len(potential_bcg.shape) == 3:
                        print("Block sample values {} to {}".format(potential_bcg[4][4][4],potential_dd[4][4][4]))
                    else:
                        print("Block sample values {} to {}".format(potential_bcg[4][4], potential_dd[4][4]))
                    print("Block {} L2 error norm: {}".format(block_name,math.sqrt(sum_squared_error[0] / sum_squared_error[1])))

    numer_sum = 0
    denom_sum = 0
    for block in block_errors:
        numer_sum += block[0]
        denom_sum += block[1]
    print("number of non-zero blocks: {}".format(len(block_errors)))
    return (numer_sum, denom_sum)



if __name__ == "__main__":
    # take optional input from system arguments
    good_file = sys.argv[1]   if len(sys.argv) > 1 else 'example_data_accurate/data-01-000030.h5'
    approx_file = sys.argv[2] if len(sys.argv) > 2 else 'example_data_with_errors/data-01-000030.h5'
    field_name = sys.argv[3]  if len(sys.argv) > 3 else 'field_potential_copy'

    # valid field names: ['field_acceleration_x', 'field_acceleration_y', 'field_potential_copy']

    print("started!")
    print("{} and {}".format(good_file, approx_file))
    (numer_sum,denom_sum) = compare_data_files(good_file, approx_file, field_name)
    print("final L2 error norm is {}".format(math.sqrt(numer_sum / denom_sum)))



